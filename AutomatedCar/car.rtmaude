---Sample Car
--- < 0 | X: 0 , Y: 0 , A: 0 , D: 0.1 , Lspeed: 5 , Aspeed: Pi/4 , MaxD: 0.1

---	  wheel: {left,right,straight} , engine: {on, off} >
---	Straight move: Full Speed
---	Turns move: 1/2 Speed and turn Aspeed Rads
---	If the car goes to far off course (50 * MAXD) the engine turs off

(tmod CAR is 

	protecting POSRAT-TIME-DOMAIN . *** Dense time domain

	sort Equation .
	--- Need to discuss how to deal with function formulas here. 

	--- To handle direction of the car steering
	sort Wheel .
	ops left right straight: -> Wheel [ctor] .
	
	--- To handle Engine on of off
	sort Engine .
	ops on off: -> Engine [ctor] .


	sort Car CarAttribute CarAttributes .
	subsort CarAttribute < CarAttributes .

	op <_|_> : Nat CarAttributes -> Reservoir [ctor format(b! o b! o b! o)] .
	op _`,_ : CarAttributes CarAttributes -> CarAttributes [ctor assoc comm] .
	--- Car Postion, X, Y and Angle and current distance to path
	op X:_ : Rat -> CarAttribute [ctor format(b! o)] .
	op Y:_ : Rat -> CarAttribute [ctor format(b! o)] .
	op A:_ : Rat -> CarAttribute [ctor format(b! o)] .
	op D:_ : Rat -> CarAttribute [ctor format(b! o b!)] .
	--- Car allowed distance from path
	op MaxD:_ : Rat -> CarAttribute [ctor format(b! o b!)] .
	--- Car Speed in a straight line and angular
	op Lspeed:_ : Rat -> CarAttribute [ctor format(b! o b!)] .
	op Aspeed:_ : Rat -> CarAttribute [ctor format(b! o b!)] .  
	--- Car Wheel Direction
	op wheel:_ : Wheel -> CarAttribute [ctor format(b! o)] .
	--- Car on or off
	op engine:_ : Engine -> CarAttribute [ctor format(b! o)] .

	---Just in case we decide to have many cars in the future
	subsort Car < System .	
	op __ : System System -> System [ctor assoc comm] .


	--- Car Path equation
	op path : Rat -> Rat .
	var x : Rat
	eq path(x) = X^3 - 153x^2 + x . --- Define the path equation Here


	---Rules to turn the Engine on and off. Unlike that we will use the turn off one
	vars d1 dmax : Rat .
	var N : Nat .
	crl [off to on]	< N | engine:off, D:d1, MaxD:dmax > => 
			< N | engine:on, D:d1, MaxD:dmax > 
		if ( abs( d1 ) < dmax ) , --- only start car if not off course

	crl [on to off] < N | engine:on, D:d1, MaxD:dmax > => 
			< N | engine:off, D:d1, MaxD:dmax > 
		if ( abs( d1 ) > 50 * dmax ) . --- stop car if it goes really far off course


	---Rules to turn the wheel (these should be simple)
	crl [straight to left]  < N | wheel:straight, D:d1, MaxD:dmax > => 
				< N | wheel:left, D:d1, MaxD:dmax> 
		if  ( d1 < -dmax ) . --- down or right of the curve 

	crl [straight to right] < N | wheel:straight, D:d1, MaxD:dmax > => 
				< N | wheel:right, D:d1, MaxD:dmax > 
		if  ( d1 > dmax ) . --- above or left of the curve 

	crl [left to straight] 	< N | wheel:left, D:d1, MaxD:dmax > => 
				< N | wheel:straight, D:d1, MaxD:dmax > 
		if  ( d1 =< dmax ) . --- on curve or less then D above or left of teh curve

	crl [right to straight] < N | wheel:left, D:d1, MaxD:dmax > => 
				< N | wheel:straight, D:d1 , MaxD:dmax > 
		if  ( d1 >= -dmax ) . -- on curve or less then D below or right of thh curve


	---Rules to tick time each wheel direction creates a progress rule
	var R : Time .
	var x1 y1 a1 ls1 as1 : Rat
	crl [tick-straight] 	< N | wheel:straight, D:d1, MaxD:dmax, 
					X:x1, Y:y1, A:a1, Lspeed:ls1, Aspeed:as1 > => 
				< N | wheel:straight, engine: on, MaxD:dmax, 
					D:(y1 + ls1 * (sin(a1)) - 
					path((x1 + ls1 * cos(a1))), 
					X:(x1 + ls1 * cos(a1)), 
					Y:(y1 + ls1 * (sin(a1)), 
					A:a1, Lspeed:ls1, Aspeed:as1 >
				in time R if ( d1 =< dmax and d1 >= -dmax ) [nonexec] .

	crl [tick-left] 	< N | wheel:left, D:d1, MaxD:dmax, 
					X:x1, Y:y1, A:a1, Lspeed:ls1, Aspeed:as1 > =>
				< N | wheel:left, engine:on, MaxD:dmax, 
					D:(y1 - ls1 * sin(a1 + as1)/2) - 
					path((x1 - ls1 * cos(a1 + as1)/2)), 
					X:(x1 - ls1 * cos(a1 + as1)/2), 
					Y:(y1 - ls1 * sin(a1 + as1)/2), 
					A:(a1 + as1), Lspeed:ls1, Aspeed: as1 > => 
				in time R if (d1 < -dmax)  [nonexec] .

	crl [tick-right]	< N | wheel:right, D:d1, MaxD:dmax, 
					X:x1, Y:y1, A:a1, Lspeed:ls1, Aspeed:as1 > =>
				< N | wheel:right, engine:on, MaxD:dmax, 
					D:(y1 + ls1 * sin(a1 - as1)/2) - 
					path((x1 + ls1 * cos(a1 - as1)/2)), 
					X:(x1 + ls1 * cos(a1 - as1)/2), 
					Y:(y1 + ls1 * sin(a1 - as1)/2), 
					A:(a1 - as1), Lspeed:ls1, Aspeed: as1 > => 
				in time R if (d1 > dmax)  [nonexec] .

endtm)

eof

---other useful stuff

(tmod MODEL-CHECK-RESERVOIR is
      including TIMED-MODEL-CHECKER .
      protecting RESERVOIR .

      ops macondo one-down : -> Prop [ctor] .
	  op res : Nat -> Prop .
	  
	  var S : System . vars W N : Nat .

      ceq {S} |= macondo = true if refill-all?(S) . 
      ceq {S} |= one-down = true if refill?(S) . 
	  
	  eq {hose(W, N) S} |= res(N) = true .
endtm)

(tmod TEST is inc MODEL-CHECK-RESERVOIR . 
	ops init1 init2 : -> System . 
	eq init1 = hose(10, 0) < 0 | thr: (15, 50), hth: 30, rte: 5 >
				< 1 | thr: (15, 50), hth: 30, rte: 5 > .
	eq init2 = hose(10, 0) < 0 | thr: (15, 50), hth: 30, rte: 5 >
				< 1 | thr: (15, 50), hth: 30, rte: 5 > 
				< 2 | thr: (15, 50), hth: 30, rte: 5 > .
endtm)

(set tick def 1 .)

(tsearch { init2 } =>* 
		 { S:System } in time < 5 .)
		 
(tsearch { init2 } =>* { < 0 | hth: 45, RA0:ReservoirAttributes >
	< 1 | hth: 10, RA1:ReservoirAttributes > 
	< 2 | hth: 10, RA2:ReservoirAttributes > } in time < 100 .)

(mc { init1 } |=t (~ [] <> macondo) in time < 5 .)

(mc { init2 } |=t (~ [] <> macondo) in time < 5 .)

(mc { init2 } |=t (~ [] <> one-down) in time < 5 .)

(mc { init2 } |=t [] ~ <> one-down in time < 5 .)
