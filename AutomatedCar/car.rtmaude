---Sample Car
--- < 0 | X: 0 , Y: 0 , A: 0 , D: 0.1 , Lspeed: 5 , Aspeed: Pi/4 ,
---	  wheel: {left,right,straight} , engine: {on, off} >

(tmod CAR is 

	protecting POSRAT-TIME-DOMAIN . *** Dense time domain

	sort Equation .
	--- Need to discuss how to deal with function formulas here. 

	--- To handle direction of the car steering
	sort Wheel .
	ops left right straight: -> Wheel [ctor] .
	
	--- To handle Engine on of off
	sort Engine .
	ops on off: -> Engine [ctor] .


	sort Car CarAttribute CarAttributes .
	subsort CarAttribute < CarAttributes .

	op <_|_> : Nat CarAttributes -> Reservoir [ctor format(b! o b! o b! o)] .
	op _`,_ : CarAttributes CarAttributes -> CarAttributes [ctor assoc comm] .
	--- Car Postion, X, Y and Angle
	op X:_ : Rat -> CarAttribute [ctor format(b! o)] .
	op Y:_ : Rat -> CarAttribute [ctor format(b! o)] .
	op A:_ : Rat -> CarAttribute [ctor format(b! o)] .
	--- Car allowed distance from path
	op D:_ : Rat -> CarAttribute [ctor format(b! o b!)] .
	--- Car Speed in a straight line and angular
	op Lspeed:_ : Rat -> CarAttribute [ctor format(b! o b!)] .
	op Aspeed:_ : Rat -> CarAttribute [ctor format(b! o b!)] .  
	--- Car Wheel Direction
	op wheel:_ : Wheel -> CarAttribute [ctor format(b! o)] .
	--- Car on or off
	op engine:_ : Engine -> CarAttribute [ctor format(b! o)] .

	---Just in case we decide to have many cars in the future
	subsort Car < System .	
	op __ : System System -> System [ctor assoc comm] .


	--- Car Path equation
	op path : Rat -> Rat .
	var x : Rat
	eq path(x) = X^3 + 3x^2 + x +5 . --- Define the path equation Here

	---Rules to turn the Engine on and off. Unlike that we will use the turn off one
	vars x1 y1 d1 : Rat .
	var N : Nat .
	crl [off to on]	< N | engine:off > => < N | engine:on, wheel:straight > 
		if ( abs(y1 - path(x1) < d1 ) , --- only start car if not off course

	crl [on to off] < N | engine:on, X:x1, Y:y1, D:d1 > => < N | engine:off, X:x1, Y:y1, D:d1 > 
		if ( abs( y1 - path(x1) ) > 3*d1 ) . --- stop car if it goes really far off course


	---Rules to turn the wheel (these should be simple)
	crl [straight to left]  < N | wheel:straight, X:x1, Y:y1, D:d1 > => < N | wheel:left, X:x1, Y:y1, D:d1 > 
		if  ( y1 - path(x1) < -d1 ) . --- down or right of the curve 

	crl [straight to right] < N | wheel:straight, X:x1, Y:y1, D:d1 > => < N | wheel:right, X:x1, Y:y1, D:d1 > 
		if  ( y1 - path(x1) > d1 ) . --- above or left of the curve 

	crl [left to straight] < N | wheel:left, X:x1, Y:y1, D:d1 > => < N | wheel:straight, X:x1, Y:y1, D:d1 > 
		if  ( y1 - path(x1) < d1 ) . --- on curve or less then D above or left of teh curve

	crl [right to straight] < N | wheel:left, X:x1, Y:y1, D:d1 > => < N | wheel:straight, X:x1, Y:y1, D:d1 > 
		if  ( y1 - path(x1) > -d1 ) . -- on curve or less then D below or right of thh curve

	---Rules to tick time each wheel direction creates a progress rule
	crl [tick-straight] 	? => ? in time T if ? [nonexec] .
	crl [tick-left] 	? => ? in time T if ? [nonexec] .
	crl [tick-right]	? => ? in time T if ? [nonexec] .

endtm)

eof

---other useful stuff

(tmod MODEL-CHECK-RESERVOIR is
      including TIMED-MODEL-CHECKER .
      protecting RESERVOIR .

      ops macondo one-down : -> Prop [ctor] .
	  op res : Nat -> Prop .
	  
	  var S : System . vars W N : Nat .

      ceq {S} |= macondo = true if refill-all?(S) . 
      ceq {S} |= one-down = true if refill?(S) . 
	  
	  eq {hose(W, N) S} |= res(N) = true .
endtm)

(tmod TEST is inc MODEL-CHECK-RESERVOIR . 
	ops init1 init2 : -> System . 
	eq init1 = hose(10, 0) < 0 | thr: (15, 50), hth: 30, rte: 5 >
				< 1 | thr: (15, 50), hth: 30, rte: 5 > .
	eq init2 = hose(10, 0) < 0 | thr: (15, 50), hth: 30, rte: 5 >
				< 1 | thr: (15, 50), hth: 30, rte: 5 > 
				< 2 | thr: (15, 50), hth: 30, rte: 5 > .
endtm)

(set tick def 1 .)

(tsearch { init2 } =>* 
		 { S:System } in time < 5 .)
		 
(tsearch { init2 } =>* { < 0 | hth: 45, RA0:ReservoirAttributes >
	< 1 | hth: 10, RA1:ReservoirAttributes > 
	< 2 | hth: 10, RA2:ReservoirAttributes > } in time < 100 .)

(mc { init1 } |=t (~ [] <> macondo) in time < 5 .)

(mc { init2 } |=t (~ [] <> macondo) in time < 5 .)

(mc { init2 } |=t (~ [] <> one-down) in time < 5 .)

(mc { init2 } |=t [] ~ <> one-down in time < 5 .)
